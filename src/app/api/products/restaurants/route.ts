import { NextResponse } from "next/server";

import { NextRequest } from "next/server";

import { connectToDb } from "@/lib/utils/connect";
import Restaurant from "@/lib/database/models/restaurants.model";
import mongoose, { Schema } from "mongoose";



export const GET = async(req:NextRequest) => {
    const {searchParams} = new URL(req.url)
     const page = searchParams.get("page") || "1"
    const limit = searchParams.get("limit") || "10"
    try {
        await connectToDb();
        const query: any = {};

        const restaurants = await Restaurant.find().skip((parseInt(page) - 1) * parseInt(limit)).limit(parseInt(limit));  
        const count = await Restaurant.countDocuments();

        return new NextResponse(JSON.stringify({
            restaurants,
            count,
            hasMore: parseInt(page) * parseInt(limit) < count}
), { status: 200 });
    } catch (error) {
        console.error("Error fetching restaurants:", error);
        return new NextResponse(
            JSON.stringify({ message: "Failed to fetch restaurants" }),
            { status: 500 }
        );
    }
}



export const POST = async(req:NextRequest) => {
    try {
        await connectToDb();
        const {restaurantData} = await req.json();
        
        console.log(restaurantData)

        // Ensure title is included in the body
        if (!restaurantData.name) {
            return new NextResponse(
                JSON.stringify({ error: "Name is required" }),
                { status: 400 }
            );
        }

        // Ensure price is included in the body
        if (restaurantData.lowestPrice === undefined || restaurantData.lowestPrice === null) {
            return new NextResponse(
                JSON.stringify({ error: "Price is required" }),
                { status: 400 }
            );
        }
        // const products = productData.map((prod:any) => ({
        //     _id:  new mongoose.Types.ObjectId(),
        //     title: prod.title,
        //     img: prod.img,
        //     desc: prod.desc,
        //     price: prod.price,
        //     catSlug: prod.catSlug,
        //     isFeatured: prod.isFeatured === 'true' ? true : false,
        //     options: prod.options.map((opt:any) => ({
        //         _id: opt._id ? new mongoose.Types.ObjectId(opt._id) : new mongoose.Types.ObjectId(),
        //         title: opt.title,
        //         additionalPrice: opt.additionalPrice
        //     })) || [],
       // }));

        // Ensure _id is not included in the body if it's generated by the database
        const restaurant = await Restaurant.create({ 
            _id: new mongoose.Types.ObjectId(),
            name: restaurantData.name, 
            lowestPrice: restaurantData.lowestPrice, 
            highestPrice: restaurantData.highestPrice,
            img: restaurantData.img, 
            locaton: restaurantData.location,
            open:restaurantData.opened,
            openTime:restaurantData.openTime,
            closingTime:restaurantData.closingTime

            // products: productData.map((prod: any) => ({
            //     _id: new mongoose.Types.ObjectId(),
            //     title: prod.title,
            //     img: prod.img,
            //     desc: prod.desc,
            //     price: prod.price,
            //     catSlug: prod.catSlug,
            //     isFeatured: prod.isFeatured,
            //     options: prod.options.map((opt: any) => ({
            //         _id: opt._id ? new mongoose.Types.ObjectId(opt._id) : new mongoose.Types.ObjectId(),
            //         title: opt.title,
            //         additionalPrice: opt.additionalPrice
            //     })) || []
            //}))
        });
        return new NextResponse(JSON.stringify(restaurant), { status: 200 });
    } catch (error) {
        console.error(error);
        return new NextResponse(
             error instanceof Error ? error.message : "Something went wrong" ,
            { status: 500 }
        );
    }
}


